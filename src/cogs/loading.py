from __future__ import annotations

import shutil
from glob import glob
from io import BytesIO
import random
import time
import typing
import zipfile
import pathlib
import re
import json
import tomlkit
import tomllib
import urllib
import hashlib
from pathlib import Path

import requests
import itertools
import collections

import tomlkit.exceptions
from src import constants
from src.types import TilingMode
from typing import Any, Optional
import os
import numpy as np
import subprocess
import asyncio
import sqlite3

import discord
from discord.ext import commands
from PIL import Image, ImageChops, ImageDraw

from ..db import TileData
from ..types import Bot, Context


class LoadingCog(commands.Cog, name="Loading", command_attrs=dict(hidden=True)):
    def __init__(self, bot: Bot):
        self.bot = bot
        self.bot.loading = False


    @commands.command()
    @commands.is_owner()
    async def loadbab(self, ctx: Context):
        """Import all sprites from BAB BE U."""
        msg = await ctx.reply("Importing...")

        bab_palette = np.array(Image.open("data/misc/bab_palette.png").convert("RGBA"))
        color_table = {
            (3, 3): (3, 1),
            (3, 2): (3, 0),
            (5, 4): (2, 3),
            (3, 0): (4, 0),
            (3, 4): (3, 3),
            (3, 5): (3, 3)
        }

        data = {}

        for directory, filenames in (  # i wish this could be a dict
                ('objects', ("characters", "devs",
                                "special", "thingify", "ui", "unsorted")),
                ('text', ("conditions", "letters",
                            "properties", "tutorial", "unsorted", "verbs"))
        ):
            for filename in filenames:
                for babdata in requests.get(
                        f"https://raw.githubusercontent.com/lilybeevee/bab-be-u/master/assets/tiles/{directory}/{filename}.json").json():
                    data[babdata.pop("name")] = babdata

        tiles = tomlkit.document()
        tiles.add(tomlkit.comment("Automatically generated by loadbab. Probably don't edit this."))
        tiles.add(tomlkit.nl())
        tiles.add(tomlkit.nl())
        tiles.add(tomlkit.nl())

        last_update = time.perf_counter()

        tilename_overrides = {
            "txt_:)": "txt_yay",
            "txt_:o": "txt_woah",
            "txt_:(": "txt_aw"
        }

        count = 0
        for name, tile in data.items():
            name = tilename_overrides.get(name, name)
            if name.startswith("txt_"):
                tilename = "text_bab_" + name[4:]
            else:
                tilename = "bab_" + name

            tilename = (
                tilename
                    .replace(">", "gt")
                    .replace(":", "colon")
                    .replace("&", "amp")
            )
            multicolor = False
            if len(tile['sprite']) > 1:
                color_x, color_y = 0, 3
                multicolor = True
            elif len(tile['color'][0]) == 2:
                color_x, color_y = tile['color'][0]
                if (color_x, color_y) in color_table:
                    color_x, color_y = color_table[(color_x, color_y)]
            else:
                with Image.open('data/palettes/vanilla/default.png') as l:
                    default_palette = np.array(
                        l.convert('RGB'), dtype=np.uint8)
                closest_color = np.argmin(np.sum(abs(
                    default_palette - np.full(default_palette.shape, tile['color'][0])), axis=2))
                color_x, color_y = (closest_color %
                                    default_palette.shape[1], closest_color //
                                    default_palette.shape[1])
                color_x, color_y = int(color_x), int(color_y)

            sprite_name = ""
            for char in name:
                if char.isalnum() or char == '_':
                    sprite_name += char
                    continue
                sprite_name += hex(ord(char))[2:]

            sprites: list[Image.Image] = []
            broken = False
            for sprite in tile['sprite']:
                sprite = requests.get(
                    f"https://raw.githubusercontent.com/lilybeevee/bab-be-u/master/assets/sprites/{urllib.parse.quote(sprite)}.png"
                ).content
                try:
                    sprite = Image.open(BytesIO(sprite)).convert("RGBA")
                except:
                    broken = True
                    break
                sprites.append(sprite)
            if broken:
                continue
            if not multicolor:
                sprite = sprites[0]
            else:
                width = max(im.width for im in sprites)
                height = max(im.height for im in sprites)
                image = Image.new("RGBA", (width, height))
                for col, sprite in zip(tile['color'], sprites):
                    color = bab_palette[*col[::-1]] if len(col) < 3 else np.array([*col, 255]) # fuck it
                    sprite = np.array(sprite)
                    sprite = np.multiply(sprite, color.astype(float) / 255, casting="unsafe").astype(np.uint8)
                    sprite = Image.fromarray(sprite)
                    image.paste(sprite, mask=sprite)
                sprite = image

            for i in range(3):
                sprite.save(f"data/sprites/bab/{sprite_name}_0_{i + 1}.png")

            table = tomlkit.inline_table()
            table.update({"sprite": sprite_name, "color": [color_x, color_y], "tiling": str(TilingMode.NONE)})
            tiles.add(tomlkit.nl())
            tiles.add(tilename, table)

            count += 1
            if time.perf_counter() - last_update > 3:
                await msg.edit(content=f"Imported {count}/{len(data.keys())} tiles...")
                last_update = time.perf_counter()

        with open(f"data/custom/bab.toml", "w+") as f:
            tomlkit.dump(tiles, f)

        await self.load_custom_tiles("bab")
        await msg.edit(content="Done. Imported all tiles from bab.")

    @commands.command()
    @commands.is_owner()
    async def loadsource(self, ctx: Context, source: str):
        """Reloads only a single source."""
        assert pathlib.Path(
            f'data/sprites/{source}').exists(), f'The source {source} doesn\'t exist.'
        self.bot.loading = True
        await self.load_custom_tiles(source)
        self.bot.loading = False
        return await ctx.send(f"Done. Loaded tile data from {source}.")


    @commands.command()
    @commands.is_owner()
    async def scrapevanilla(self, ctx: Context):
        """Scrapes tile data from the vanilla worlds' .ld files."""
        cached_exists = set()

        async with self.bot.db.conn.cursor() as cur:
            await cur.execute(
                "DELETE FROM tiles WHERE source == 'baba' OR source == 'new_adv' OR source == 'museum'"
            )

        async def exists(tile: str):
            nonlocal ctx, cached_exists
            exists = tile in cached_exists or (await self.bot.db.tile(tile)) is not None
            cached_exists.add(tile)
            return exists

        await ctx.reply("Scraping tile metadata...")
        async with ctx.typing():
            for world in constants.VANILLA_PATHS:
                print(f"Scraping from {world}...")
                ld_files = (Path("data/levels") / world).glob("*.ld")
                sprites = {}
                for file in ld_files:
                    with open(file, "r") as f:
                        data = f.read().replace("\r\n", "\n")
                    if (start := data.find("[tiles]")) == -1:
                        continue
                    data = data[start + len("[tiles]"):]
                    end = data.find("\n[")
                    if end != -1:
                        data = data[:end]
                    data = data.strip()
                    # We now have a name=value file entry, essentially an ini
                    entries = {}
                    for line in data.splitlines():
                        eq = line.find("=")
                        if eq == -1: continue
                        name, value = line[:eq], line[eq+1:]
                        entries[name] = value
                    if not len(entries):
                        continue
                    changed = [id for id in entries["changed"].split(",") if len(id)]
                    tiles = {}
                    for object_id in changed:
                        try:
                            sprite_name = entries[f"{object_id}_image"]
                            if not await exists(sprite_name):
                                data = {
                                    name[len(object_id) + 1:]: value for name, value in entries.items()
                                    if name.startswith(object_id)
                                        and name != sprite_name
                                }
                                data["object"] = object_id
                                if int(data.get("root", 1)):
                                    data["source"] = "vanilla"
                                tiles[sprite_name] = data
                        except KeyError:
                            continue
                    for name, data in tiles.items():
                        if name not in sprites:
                            sprites[name] = {}
                        for key, value in data.items():
                            if key not in sprites[name]:
                                sprites[name][key] = []
                            sprites[name][key].append(value)
                # Consolidate the entries
                world_data = {}
                world_sprites = set()
                for name, data in sprites.items():
                    data = {key: collections.Counter(value).most_common(1)[0][0] for key, value in data.items()}
                    if (a := data.get("activecolour")) is not None:
                        data["colour"] = a
                    if (c := data.get("colour")) is not None:
                        data["colour"] = [int(c) for c in c.split(',')]
                    async with self.bot.db.conn.cursor() as cur:
                        res = await cur.execute(
                            "SELECT active_color_x, active_color_y, tiling FROM tiles WHERE object_id == ?",
                            data["object"]
                        )
                        row = await res.fetchone()
                        orig_color_x, orig_color_y, orig_tiling = row
                        data["colour"] = data.get("colour", [orig_color_x, orig_color_y])
                        data["tiling"] = int(data.get("tiling", orig_tiling))
                    data["tiling"] = str(TilingMode(data["tiling"]))
                    final_data = {
                        "color": data["colour"],
                        "tiling": data["tiling"],
                        "sprite": name
                    }
                    if "source" in data:
                        final_data["source"] = data["source"]
                    world_data[name] = final_data
                    world_sprites.add(name)

                # Now that we have the metadata, we need to add the sprites
                sprite_path = Path("data/sprites") / world
                world_sprite_path = Path("data/levels") / world / "Sprites"
                data_path = (Path("data/custom") / world).with_suffix(".toml")

                if sprite_path.exists():
                    shutil.rmtree(sprite_path)

                sprite_path.mkdir()
                # Copy the sprites
                for sprite in world_sprites:
                    for file in world_sprite_path.glob(f"{sprite}_*.png"):
                        shutil.copyfile(file, sprite_path / file.name)

                # Create the .toml
                doc = tomlkit.document()
                doc.add(tomlkit.comment("Generated by =scrapevanilla. Do not edit."))
                doc.add(tomlkit.nl())
                doc.add(tomlkit.nl())
                for name, data in world_data.items():
                    print("\t", name, "\t", data)
                    table = tomlkit.inline_table()
                    table.update(data)
                    doc.add(tomlkit.nl())
                    doc.add(name, table)
                with open(data_path, "w+") as f:
                    tomlkit.dump(doc, f)

        await ctx.reply("Scraped vanilla worlds. Run =loadcustom.")
        self.bot.loading = False

    @commands.command()
    @commands.is_owner()
    async def loaddata(self, ctx: Context, flag: bool = False):
        """Reloads tile data from the world map, editor, and custom files.

        The boolean flag deletes all tiles from the database before
        updating with new tiles. [slow, do not do unless necessary]
        """
        self.bot.loading = True
        if flag:
            # Flush the tile database since it all gets reconstructed anyway
            await self.bot.db.conn.execute('DELETE FROM tiles')
        del self.bot.db.filter_cache  # Just to make absolutely sure that it gets flushed
        self.bot.db.filter_cache = {}
        await self.load_initial_tiles()
        await self.load_editor_tiles()
        await self.load_custom_tiles()
        self.bot.loading = False
        return await ctx.send("Done. Loaded all tile data.")

    @commands.command()
    @commands.is_owner()
    async def loadpalettes(self, ctx: Context):
        """Refetches palette data from the filesystem."""
        self.bot.loading = True
        await self.bot.db.conn.execute('DELETE FROM palettes')
        self.bot.db.palette_cache = {}

        async with self.bot.db.conn.cursor() as cur:
            pals = []
            for path in pathlib.Path("data/palettes/").glob(f"*/*.png"):
                source = path.parts[-2]
                name = path.stem
                buf = BytesIO()
                with Image.open(path) as im:
                    im = im.convert("RGBA")
                    hashed_im = hashlib.md5(im.tobytes()).hexdigest()
                    im.save(buf, format = "PNG")
                buf.seek(0)
                pals.append({"name": name, "source": source, "data": buf.getvalue(), "hash": hashed_im})
            await cur.executemany(
                '''
                INSERT INTO palettes
                VALUES (
                    :name,
                    :source,
                    :data,
                    :hash
                )
                ON CONFLICT(hash) DO NOTHING;
                ''',
                pals
            )
        await self.bot.db.store_palettes()
        self.bot.loading = False
        return await ctx.send("Done. Reloaded palette data.")

    async def load_initial_tiles(self) -> dict:
        """Loads tile data from `data/values.lua` files."""
        # values.lua contains the data about which color (on the palette) is
        # associated with each tile.
        with open("data/values.lua", errors='ignore') as fp:
            data = fp.read()

        start = data.find("tileslist =\n")
        end = data.find("\n}", start)

        assert start > 0 and end > 0, "Failed to load values.lua!"
        spanned = data[start:end]

        def prepare(d: dict[str, Any]) -> dict[str, Any]:
            """From game format into DB format."""
            if d.get("type") is not None:
                d["text_type"] = d.pop("type")
            if d.get("image") is not None:
                d["sprite"] = d.pop("image")
            if d.get("colour") is not None:
                inactive = d.pop("colour").split(",")
                d["inactive_color_x"] = int(inactive[0])
                d["inactive_color_y"] = int(inactive[1])
            if d.get("activecolour") is not None:
                active = d.pop("activecolour").split(",")
                d["active_color_x"] = int(active[0])
                d["active_color_y"] = int(active[1])
            return d

        object_pattern = re.compile(
            r"(object\d+) =\n\t\{"
            r"\n\s*name = \"([^\"]*)\","
            r"\n\s*sprite = \"([^\"]*)\","
            r"\n.*\n.*\n\s*tiling = (-1|\d),"
            r"\n\s*type = (\d),"
            r"\n\s*(?:argextra = .*,\n\s*)?(?:argtype = .*,\n\s*)?"
            r"colour = \{(\d), (\d)},"
            r"\n\s*(?:active = \{(\d), (\d)},\n\s*)?"
            r".*\n.*\n.*\n\s*}",
        )
        objects: dict[str, dict[str, Any]] = {}
        for match in re.finditer(object_pattern, spanned):
            obj, name, sprite, tiling, type, c_x, c_y, a_x, a_y = match.groups()
            print(f"Loading {name}")
            a_x = c_x if a_x is None else a_x
            a_y = c_y if a_y is None else a_y
            active_x = int(a_x)
            active_y = int(a_y)
            inactive_x = int(c_x)
            inactive_y = int(c_y)
            tiling = TilingMode(int(tiling))
            if tiling == TilingMode.TILING:
                # Check for diagonal tiling
                if pathlib.Path(f"data/sprites/vanilla/{sprite}_16_1.png").exists():
                    tiling = TilingMode.DIAGONAL_TILING
            tiling = str(tiling)
            objects[name] = dict(
                sprite=sprite,
                tiling=str(tiling),
                color=[active_x, active_y],
                author="Hempuli",
                object_id=obj,
                version=0
            )

        doc = tomlkit.document()
        doc.add(tomlkit.comment("Generated by =loaddata. Do not edit."))
        doc.add(tomlkit.nl())
        doc.add(tomlkit.nl())
        for name, data in objects.items():
            print("\t", name, "\t", data)
            table = tomlkit.inline_table()
            table.update(data)
            doc.add(tomlkit.nl())
            doc.add(name, table)
        with open("data/custom/vanilla.toml", "w+") as f:
            tomlkit.dump(doc, f)

    async def load_editor_tiles(self):
        """Loads tile data from `data/editor_objectlist.lua`."""

        with open("data/editor_objectlist.lua", errors="replace") as fp:
            data = fp.read()

        start = data.find("editor_objlist = {")
        end = data.find("\n}", start)
        assert start > 0 and end > 0
        spanned = data[start:end]

        object_pattern = re.compile(
            r"\[\d+] = \{"
            r"\n\s*name = \"([^\"]*)\","
            r"(?:\n\s*sprite = \"([^\"]*)\",)?"
            r"\n.*"
            r"\n\s*tags = \{((?:\"[^\"]*?\"(?:,\"[^\"]*?\")*)?)},"
            r"\n\s*tiling = (-1|\d),"
            r"\n\s*type = (\d),"
            r"\n.*"
            r"\n\s*colour = \{(\d), (\d)},"
            r"(?:\n\s*colour_active = \{(\d), (\d)})?"
        )
        tag_pattern = re.compile(r"\"([^\"]*?)\"")
        objects = {}
        for match in re.finditer(object_pattern, spanned):
            name, sprite, raw_tags, tiling, text_type, c_x, c_y, a_x, a_y = match.groups()
            sprite = name if sprite is None else sprite
            a_x = c_x if a_x is None else a_x
            a_y = c_y if a_y is None else a_y
            active_x = int(a_x)
            active_y = int(a_y)
            inactive_x = int(c_x)
            inactive_y = int(c_y)
            tiling = TilingMode(int(tiling))
            if tiling == TilingMode.TILING:
                # Check for diagonal tiling
                if pathlib.Path(f"data/sprites/vanilla/{sprite}_16_1.png").exists():
                    tiling = TilingMode.DIAGONAL_TILING
            tiling = str(tiling)
            text_type = int(text_type)
            tag_list = []
            for tag in re.finditer(tag_pattern, raw_tags):
                # hack but i am Not touching that regex
                tag_list.append(tag.group(0).replace('"', ''))

            objects[name] = dict(
                sprite=sprite,
                tiling=str(tiling),
                color=[active_x, active_y],
                author="Hempuli",
                source="vanilla",
                tags=tag_list,
                version=1
            )

        doc = tomlkit.document()
        doc.add(tomlkit.comment("Generated by =loaddata. Do not edit."))
        doc.add(tomlkit.nl())
        doc.add(tomlkit.nl())
        for name, data in objects.items():
            print("\t", name, "\t", data)
            table = tomlkit.inline_table()
            table.update(data)
            doc.add(tomlkit.nl())
            doc.add(name, table)
        with open("data/custom/editor.toml", "w+") as f:
            tomlkit.dump(doc, f)

    async def load_custom_tiles(self, file='*'):
        """Loads custom tile data from `data/custom/*.toml`"""

        def prepare(source: str, name: str, d: dict[str, Any]) -> dict[str, Any]:
            """From config format to db format."""
            print(f"Loading {name}")
            db_dict = {key: value for key, value in d.items()}
            db_dict["name"] = name
            inactive = d.pop("color")
            if d.get("active_color") is not None:
                db_dict["inactive_color_x"] = inactive[0]
                db_dict["inactive_color_y"] = inactive[1]
                db_dict["active_color_x"] = d["active_color"][0]
                db_dict["active_color_y"] = d["active_color"][1]
            else:
                db_dict["inactive_color_x"] = db_dict["active_color_x"] = inactive[0]
                db_dict["inactive_color_y"] = db_dict["active_color_y"] = inactive[1]
            db_dict["version"] = d.get("version", 2)
            db_dict["source"] = d.get("source", source)
            tmode = TilingMode.parse(d.get("tiling", "none"))
            assert tmode is not None, f"Tiling mode {d['tiling']} is not valid"
            db_dict["tiling"] = str(tmode)
            db_dict["tags"] = "\t".join(d.get("tags", []))
            db_dict["extra_frames"] = "\t".join(str(value) for value in d.get("extra_frames", []))
            db_dict["object_id"] = d.get("object_id")
            return db_dict

        async with self.bot.db.conn.cursor() as cur:
            for path in pathlib.Path("data/custom").glob(f"{file}.toml"):
                source = path.parts[-1].split(".")[0]
                with open(path) as fp:
                    try:
                        objects = [prepare(source, name, obj) for name, obj in tomlkit.load(fp).items()]
                    except Exception as err:
                        raise AssertionError(f"Failed to load `{path}`!\n```\n{err}\n```")
                await cur.executemany(
                    '''
                    INSERT INTO tiles
                    VALUES (
                        :name,
                        :sprite,
                        :source,
                        :version,
                        :inactive_color_x,
                        :inactive_color_y,
                        :active_color_x,
                        :active_color_y,
                        :tiling,
                        :tags,
                        :extra_frames,
                        :object_id
                    )
                    ON CONFLICT(name, version)
                    DO UPDATE SET
                        sprite=excluded.sprite,
                        source=excluded.source,
                        inactive_color_x=excluded.inactive_color_x,
                        inactive_color_y=excluded.inactive_color_y,
                        active_color_x=excluded.active_color_x,
                        active_color_y=excluded.active_color_y,
                        tiling=excluded.tiling,
                        tags=excluded.tags,
                        extra_frames=excluded.extra_frames,
                        object_id=excluded.object_id;
                    ''',
                    objects
                )

    @commands.command()
    @commands.is_owner()
    async def loadletters(self, ctx: Context):
        await self.bot.db.conn.execute("DELETE FROM letters")

        with open("data/letters/letters.toml", "rb") as f:
            letters: dict[str, dict] = tomllib.load(f)
        data = []
        seen_values = set()
        for letter, entry in letters.items():
            if entry["value"] in seen_values:
                raise AssertionError(f"Entry {letter} is duplicated with character {entry['value']}!")
            seen_values.add(entry["value"])
            for mode, paths in entry.items():
                if mode == "value": continue
                for path in paths:
                    with Image.open(Path("data/letters") / letter / path) as im:
                        img_data = np.array(im.convert("LA"))[..., 1] > 0
                    _, width = img_data.shape
                    width //= 3
                    print(path, width)
                    io = BytesIO()
                    np.save(io, [img_data[:, i * width : (i + 1) * width] for i in range(3)])
                    data.append((entry["value"], width, mode, io.getvalue()))

        await self.bot.db.conn.executemany(
            '''
            INSERT INTO letters
            VALUES (?, ?, ?, ?)
            ''',
            data
        )
        return await ctx.send("Letters loaded.")


    @commands.command()
    @commands.is_owner()
    async def loadbaba(self, ctx: Context, *, path: str):
        """Adds all missing files from the base game. Should only have to be run when the game updates."""
        path = pathlib.Path(path) / "Data"
        assert path.exists, "Invalid directory!"
        bot_path = pathlib.Path(os.getcwd()) / "data"

        def replace(src, dst, *args):
            if os.path.exists(src):
                if os.path.exists(dst):
                    shutil.rmtree(dst)
                shutil.copytree(src, dst, *args)

        message = await ctx.reply(f"Adding sprites...")
        replace(path / "Sprites", bot_path / "sprites" / "vanilla")
        shutil.copytree(path / "Sprites", bot_path / "sprites" / "vanilla", dirs_exist_ok=True)
        shutil.copytree(path / "Palettes", bot_path / "palettes" / "vanilla", dirs_exist_ok=True)
        shutil.copy2(path / "merged.ttf", bot_path / "fonts" / "default.ttf")
        shutil.copy2(path / "Editor" / "editor_objectlist.lua", bot_path / "editor_objectlist.lua")
        shutil.copy2(path / "values.lua", bot_path / "values.lua")
        for world in glob(str(path / "Worlds" / "*")):
            world = pathlib.Path(world)
            world_name = world.stem
            await message.edit(content=f"Adding world `{world_name}`...")
            if (bot_world_path := pathlib.Path(bot_path) / "levels" / world_name).exists():
                shutil.rmtree(bot_world_path)
            shutil.copytree(world, bot_world_path, dirs_exist_ok=True)
            replace(world / "Palettes", bot_path / "palettes" / world_name)
            replace(world / "Sprites", bot_path / "sprites" / world_name)
            replace(world / "Images", bot_path / "images" / world_name)
        await message.edit(content="Done.")


async def setup(bot: Bot):
    await bot.add_cog(LoadingCog(bot))
